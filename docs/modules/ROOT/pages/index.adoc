= Quarkus Axonframework Extension
include::./includes/attributes.adoc[]

This guide explains how to use quarkus together with the axon framework.

== What is Quarkus Axonframework

Axon Framework assists developers in implementing message-driven applications. That means that you can implement applications using Event Sourcing and CQRS.

== Creating an Event Sourcing Application

=== The domain

Gift cards can be issued with an initial amount. +
Those gift cards can then be used for payments. +
Under some circumstances, it is necessary to cancel the last payment.

=== Example architecture
The model handles the commands.

A rest service for requesting the current amount of the card uses a query. The query is handled by an in-memory projection.

The commands are submitted by a test.

=== Getting started

Add the following import to your build file:

[source,xml,subs=attributes+]
----
<dependency>
    <groupId>io.quarkiverse.axonframework-extension</groupId>
    <artifactId>quarkus-axonframework-extension</artifactId>
    <version>{project-version}</version>
</dependency>
----

You can now create the commands, events and the model.

==== Events and Commands

[source,java]
----
public class Api {
    public record IssueCardCommand(@TargetAggregateIdentifier String id, int initialAmount) { }
    public record CardIssuedEvent(String id, int amount) { }
    public record RedeemCardCommand(@TargetAggregateIdentifier String id, int amount) { }
    public record CardRedeemedEvent(String id, int amount) { }
    public record UndoLatestRedemptionCommand(@TargetAggregateIdentifier String id, int amount) { }
    public record LatestRedemptionUndoneEvent(String id, int amount) { }
}
----

==== Model

The model contains the domain logic. It contains the handlers

* CommandHandler and
* EventSourcingHandler

As an example for a domain service, the Command UndoLatestRedemptionCommand is handled not by the root aggregate, but by a domain service.

The EventSourcingHandler methods are necessary for tracking the state of the aggregate, which is used for validation.

[source,java]
----
public class Giftcard {

    @AggregateIdentifier
    private String id;
    private int currentAmount;
    private final List<Integer> cardRedemptions = new ArrayList<>();

    Giftcard() {
        // necesarry for the axon framework
    }

    @CommandHandler
    Giftcard(Api.IssueCardCommand command) {
        if (command == null) {
            throw new IllegalArgumentException("command mustn't be null");
        }
        apply(new Api.CardIssuedEvent(command.id(), command.initialAmount()));
        Log.infof("new card with the id %s and the initial amount %s was issued", command.id(), command.initialAmount());
    }

    @EventSourcingHandler
    void handle(Api.CardIssuedEvent event) {
        this.id = event.id();
        this.currentAmount = event.amount();
    }

    @CommandHandler
    void handle(Api.RedeemCardCommand command) {
        if (this.currentAmount < command.amount()) {
            throw new IllegalArgumentException(
                    "amount(" + command.amount() + ") must be less than current card amount(" + currentAmount + ")");
        }
        apply(new Api.CardRedeemedEvent(id, command.amount()));
        Log.infof("card was redeemed by %s", command.amount());
    }

    @EventSourcingHandler
    void handle(Api.CardRedeemedEvent event) {
        this.currentAmount -= event.amount();
        cardRedemptions.add(event.amount());
    }

    public void undoRedemption(int amount) {
        Optional<Integer> lastestRedeemedAmount = lastestRedeemedAmount();
        if (lastestRedeemedAmount.isEmpty() || lastestRedeemedAmount.get() != amount) {
            throw new IllegalArgumentException("amount must be the lastest redeem amount");
        } else {
            apply(new Api.LatestRedemptionUndoneEvent(id, amount));
            Log.infof("latest redemption was undone");
        }
    }

    private Optional<Integer> lastestRedeemedAmount() {
        if (!cardRedemptions.isEmpty()) {
            return Optional.of(cardRedemptions.get(cardRedemptions.size() - 1));
        }
        return Optional.empty();
    }

    @EventSourcingHandler
    void handle(Api.LatestRedemptionUndoneEvent event) {
        cardRedemptions.remove(cardRedemptions.size() - 1);
        this.currentAmount += event.amount();
    }

    @ExceptionHandler
    public void handleAll(Exception exception) {
        throw new CommandExecutionException("wrapped exception in details", exception);
    }

}
----

===== Domain service
The domain service gets the repository for the gift card injected. +
It handles the undo command by loading the aggregate from the repository and then invoking a method on the aggregate.

This is useful if one command modifies more aggregates.

[source,java]
----
@ApplicationScoped
public class DomainServiceExample {

    @Inject
    Repository<Giftcard> giftcardRepository;

    @CommandHandler
    void handle(Api.UndoLatestRedemptionCommand command) {
        Aggregate<Giftcard> giftcardAggregate = giftcardRepository.load(command.id());
        giftcardAggregate.execute(giftcard -> giftcard.undoRedemption(command.amount()));
    }

    @ExceptionHandler
    public void handleAll(Exception exception) {
        throw new CommandExecutionException("wrapped exception in details", exception);
    }

}

----

==== Projection
The current amount is built and queried using a projection.

The project listens to the necessary events using the annotation EventHandler and updates the amount of each gift card in memory in a simple map.

It also handles the query with a method annotated by QueryHandler.
It gets the amount from the in memory map and returns the id and the amount of the card.

[source,java]
----
@ApplicationScoped
public class GiftcardProjection {

    private final Map<String, GiftcardDto> giftcards = new HashMap<>();

    @QueryHandler
    GiftcardDto handle(GiftcardQuery query) {
        return giftcards.get(query.id());
    }

    @EventHandler
    void handle(Api.CardIssuedEvent event) {
        giftcards.put(event.id(), new GiftcardDto(event.id(), event.amount()));
    }

    @EventHandler
    void handle(Api.CardRedeemedEvent event) {
        giftcards.get(event.id()).redeem(event.amount());
    }

    @EventHandler
    void handle(Api.LatestRedemptionUndoneEvent event) {
        giftcards.get(event.id()).undoLatestRedemption(event.amount());
    }
}

----


==== Rest Service

The rest service gets the QueryGateway injected and queries a card by id, using the GiftcardQuery.

[source,java]
----
@Path("giftcard")
public class GiftcardResource {

    @Inject
    QueryGateway queryGateway;

    @GET
    public Uni<GiftcardDto> getGiftcard(@RestQuery String id) {
        return Uni.createFrom()
                .future(() -> queryGateway.query(new GiftcardQuery(id), GiftcardDto.class));
    }

}
----

==== Test

The test submits the commands using the injected CommandGateway. +
It uses the rest service to verify the expected current amount of the gift card. +
It also verifies that exceptions are thrown if commands are not valid.

[source,java]
----
@QuarkusTest
@TestHTTPEndpoint(GiftcardResource.class)
class ApplicationTest {

    @Inject
    CommandGateway commandGateway;

    @Test
    void wholeUseCaseTest() {
        var cardId = UUID.randomUUID().toString();
        commandGateway.sendAndWait(new Api.IssueCardCommand(cardId, 20));
        commandGateway.sendAndWait(new Api.RedeemCardCommand(cardId, 2));
        commandGateway.sendAndWait(new Api.RedeemCardCommand(cardId, 4));
        commandGateway.sendAndWait(new Api.RedeemCardCommand(cardId, 3));

        assertThatException().isThrownBy(() -> commandGateway.sendAndWait(new Api.RedeemCardCommand(cardId, 12)))
                .havingCause()
                .withMessageContaining("must be less than current card amount");

        RestAssured.given().queryParam("id", cardId)
                .when().get()
                .then()
                .body("id", CoreMatchers.equalTo(cardId), "currentAmount", CoreMatchers.equalTo(11));

        commandGateway.sendAndWait(new Api.UndoLatestRedemptionCommand(cardId, 3));
        assertThatException().isThrownBy(() -> commandGateway.sendAndWait(new Api.UndoLatestRedemptionCommand(cardId, 2)))
                .havingCause()
                .withMessageContaining("amount must be the lastest redeem amount");

        RestAssured.given().queryParam("id", cardId)
                .when().get()
                .then()
                .body("id", CoreMatchers.equalTo(cardId), "currentAmount", CoreMatchers.equalTo(14));
    }

}
----

[[extension-configuration-reference]]
== Extension Configuration Reference

include::includes/quarkus-axonframework-extension.adoc[leveloffset=+1,opts=optional]
